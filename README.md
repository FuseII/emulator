
# Задание №1. Поиск максимума в массиве (Архитектура Гарвардская, двухадресная, без знака)


## Описание задачи: 
Написать программу на ассемблере, которая находит максимальный элемент в массиве целых чисел без знака, используя архитектуру Гарвардская и двухадресные команды.

## Входные данные
Массив из 6-15 элементов, хранящийся в памяти данных.

## Выходные данные

Максимальный элемент массива, хранящийся в регистре.

## Регистры
• AX: Используется для хранения текущего элемента массива и результата сравнения.<br>
• BX: Указатель на начало массива (хранится в памяти данных).<br>
• CX: Счетчик элементов массива.<br>
• DX: Хранит максимальный элемент массива.

## Код:
```
section .data
    array db 3, 5, 1, 7, 2, 8, 4, 6, 9, 0  ; массив из 10 элементов
    length db 10                           ; длина массива

_start:
    ; Инициализация указателей и переменных
    mov cx, [length]                      ; длина массива
    mov bx, [array]                             ; указатель массива
    mov ax, [bx]                  ; первый элемент массива как текущий максимум

next_element:
    inc bx                                 ; переходим к следующему элементу
    cmp bx, cx                            ; проверяем, достигли ли конца массива
    jge finish                              ; если достигли конца, выходим из цикла

    mov dx, [bx]                  ; загружаем текущий элемент
    cmp ax, dx                              ; сравниваем с текущим максимумом
    jge next_element                        ; если текущий элемент меньше, переходим к следующему

    mov ax, dx                              ; обновляем максимум

    jmp next_element                        ; продолжаем цикл

finish:
	ret

```
## Объяснение
1.  Инициализация: Программа загружает сегмент данных, инициализирует CX с размером массива, BX с адресом начала массива (из array_ptr) и DX первым элементом массива.
2. Цикл: В цикле loop_start текущий элемент загружается в AX и сравнивается с DX. Если текущий элемент больше, то DX обновляется.
3. Переход к следующему элементу: BX увеличивается на 2 для перехода к следующему элементу массива (размер слова 2 байта).
4. Счетчик: Счетчик CX уменьшается на 1.
5. Проверка счетчика: Если CX не равен нулю, цикл продолжается.
6. Вывод результата: Максимальный элемент находится в регистре AX. Добавьте код для вывода результата по своему усмотрению.

## Заметки:
• Гарвардская архитектура: Команды и данные хранятся в разных адресных пространствах. В этом примере, array_ptr хранит адрес начала массива в памяти данных, доступ к которому осуществляется через ds:bx.<br>
• Двухадресная команда add: В программе используется add bx, 2 для перехода к следующему элементу массива.<br>
• Сравнение без знака: Вместо jg используется ja (jump above), чтобы сравнить числа без учета знака.

# Задание №2. Свертка двух массивов (Архитектура Гарвардская, двухадресная, без знака)

## Описание задачи
Написать программу на ассемблере, которая выполняет свертку двух массивов с 6 элементами, содержащих целые числа без знака, используя архитектуру Гарвардская и двухадресные команды.

## Входные данные
Два массива (array1 и array2), хранящихся в памяти данных.

## Выходные данные Результат свертки, хранящийся в регистре AX.

## Регистры
• AX: Используется для хранения результата свертки.<br>
• BX: Указатель на первый элемент массива array1 (хранится в памяти данных).<br>
• CX: Указатель на первый элемент массива array2 (хранится в памяти данных).<br>
• DX: Счетчик элементов массива.

## Код
```
.model small
.stack 100h

.data
    array_1 dw 5, 2, 7, 1, 4, 3  ; Первый массив (без знака)
    array_2 dw 1, 3, 2, 5, 0, 2  ; Второй массив (без знака)
    array_size dw 12           ; Размер массива

    mov bx, [array_1]  ; Загрузка указателя на начало массива array1
    mov cx, [array_2]  ; Загрузка указателя на начало массива array2
    mov dx, array_size    ; Загрузка размера массива
    mov ax, 0             ; Инициализация результата свертки

    loop_start:
        mov ex, [bx]      ; Загрузка текущего элемента array1
        mul ex, [cx]              ; Умножение текущих элементов
        add ax, ex          ; Сложение с результатом свертки
        inc bx             ; Переход к следующему элементу array1
        inc cx             ; Переход к следующему элементу array2
        cmp cx, dx              ; проверяем, достигли ли конца массива
        jge finish
        jmp loop_start

    finish:
        ret
```

## Объяснение:
1. Инициализация: Программа загружает сегмент данных, инициализирует BX, CX, DX и AX начальными значениями.
2. Цикл: В цикле loop_start текущие элементы массивов array_1 и array_2 умножаются, результат складывается с результатом свертки (AX).
3. Переход к следующему элементу: BX и CX увеличиваются на 2 для перехода к следующему элементу.
4. Счетчик: Счетчик DX уменьшается на 1.
5. Проверка счетчика: Если DX не равен нулю, цикл продолжается.
6. Вывод результата: Результат свертки хранится в регистре AX. Добавьте код для вывода результата по своему усмотрению.

## Заметки:
• Гарвардская архитектура: Команды и данные хранятся в разных адресных пространствах. В этом примере, array1_ptr и array2_ptr хранят адреса начала массивов в памяти данных, доступ к которым осуществляется через ds:bx и ds:cx.<br>
• Двухадресная команда add: В программе используются add bx, 2 и add cx, 2 для перехода к следующему элементу массива.<br>
• Числа без знака: Программа использует числа без знака, поэтому нет необходимости в команде mul (умножение без знака).