
# Задание №1. Поиск максимума в массиве (Архитектура Гарвардская, двухадресная, без знака)


## Описание задачи: 
Написать программу на ассемблере, которая находит максимальный элемент в массиве целых чисел без знака, используя архитектуру Гарвардская и двухадресные команды.

## Входные данные
Массив из 6-15 элементов, хранящийся в памяти данных.

## Выходные данные

Максимальный элемент массива, хранящийся в регистре.

## Регистры
• AX: Используется для хранения текущего элемента массива и результата сравнения.<br>
• BX: Указатель на начало массива (хранится в памяти данных).<br>
• CX: Счетчик элементов массива.<br>
• DX: Хранит максимальный элемент массива.

## Код:
```
.model small
.stack 100h

.data
    array dw 10, 5, 2, 8, 12, 7  ; Массив данных (без знака)
    array_size dw 6            ; Размер массива
    array_ptr dw offset array  ; Указатель на начало массива

.code
main proc
    mov ax, @data         ; Загрузка сегмента данных
    mov ds, ax             ; Установка сегмента данных

    mov cx, array_size    ; Загрузка размера массива
    mov bx, [array_ptr]     ; Загрузка указателя на массив
    mov dx, [bx]          ; Инициализация максимального элемента первым элементом

    loop_start:
        mov ax, [bx]      ; Загрузка текущего элемента массива
        cmp ax, dx          ; Сравнение с текущим максимальным элементом
        ja max_found        ; Если текущий элемент больше - обновляем максимальный
        add bx, 2            ; Переход к следующему элементу
        dec cx              ; Декремент счетчика
        jnz loop_start    ; Цикл по массиву

    max_found:
        mov ax, dx          ; Перемещение максимального элемента в AX
        
    ; Вывод результата (добавьте код для вывода результата в соответствии с вашими предпочтениями)
    
    mov ah, 4ch            ; Код прерывания для завершения программы
    int 21h               ; Вызов прерывания

main endp
end main

```
## Объяснение
1.  Инициализация: Программа загружает сегмент данных, инициализирует CX с размером массива, BX с адресом начала массива (из array_ptr) и DX первым элементом массива.
2. Цикл: В цикле loop_start текущий элемент загружается в AX и сравнивается с DX. Если текущий элемент больше, то DX обновляется.
3. Переход к следующему элементу: BX увеличивается на 2 для перехода к следующему элементу массива (размер слова 2 байта).
4. Счетчик: Счетчик CX уменьшается на 1.
5. Проверка счетчика: Если CX не равен нулю, цикл продолжается.
6. Вывод результата: Максимальный элемент находится в регистре AX. Добавьте код для вывода результата по своему усмотрению.

## Заметки:
• Гарвардская архитектура: Команды и данные хранятся в разных адресных пространствах. В этом примере, array_ptr хранит адрес начала массива в памяти данных, доступ к которому осуществляется через ds:bx.<br>
• Двухадресная команда add: В программе используется add bx, 2 для перехода к следующему элементу массива.<br>
• Сравнение без знака: Вместо jg используется ja (jump above), чтобы сравнить числа без учета знака.

# Задание №2. Свертка двух массивов (Архитектура Гарвардская, двухадресная, без знака)

## Описание задачи
Написать программу на ассемблере, которая выполняет свертку двух массивов с 6 элементами, содержащих целые числа без знака, используя архитектуру Гарвардская и двухадресные команды.

## Входные данные
Два массива (array1 и array2), хранящихся в памяти данных.

## Выходные данные Результат свертки, хранящийся в регистре AX.

## Регистры
• AX: Используется для хранения результата свертки.<br>
• BX: Указатель на первый элемент массива array1 (хранится в памяти данных).<br>
• CX: Указатель на первый элемент массива array2 (хранится в памяти данных).<br>
• DX: Счетчик элементов массива.

## Код
```
.model small
.stack 100h

.data
    array1 dw 5, 2, 7, 1, 4, 3  ; Первый массив (без знака)
    array2 dw 1, 3, 2, 5, 0, 2  ; Второй массив (без знака)
    array_size dw 6           ; Размер массива
    array1_ptr dw offset array1 ; Указатель на начало массива array1
    array2_ptr dw offset array2 ; Указатель на начало массива array2

.code
main proc
    mov ax, @data         ; Загрузка сегмента данных
    mov ds, ax             ; Установка сегмента данных

    mov bx, [array1_ptr]  ; Загрузка указателя на начало массива array1
    mov cx, [array2_ptr]  ; Загрузка указателя на начало массива array2
    mov dx, array_size    ; Загрузка размера массива
    mov ax, 0             ; Инициализация результата свертки

    loop_start:
        mov ax, [bx]      ; Загрузка текущего элемента array1
        mul [cx]              ; Умножение текущих элементов
        add ax, ax          ; Сложение с результатом свертки
        add bx, 2            ; Переход к следующему элементу array1
        add cx, 2            ; Переход к следующему элементу array2
        dec dx              ; Декремент счетчика
        jnz loop_start    ; Продолжение цикла, если не все элементы обработаны

    ; Результат свертки хранится в AX
    ; Вывод результата (добавьте код для вывода результата в соответствии с вашими предпочтениями)

    mov ah, 4ch            ; Код прерывания для завершения программы
    int 21h               ; Вызов прерывания

main endp
end main
```

## Объяснение:
1. Инициализация: Программа загружает сегмент данных, инициализирует BX, CX, DX и AX начальными значениями.
2. Цикл: В цикле loop_start текущие элементы массивов array1 и array2 умножаются, результат складывается с результатом свертки (AX).
3. Переход к следующему элементу: BX и CX увеличиваются на 2 для перехода к следующему элементу.
4. Счетчик: Счетчик DX уменьшается на 1.
5. Проверка счетчика: Если DX не равен нулю, цикл продолжается.
6. Вывод результата: Результат свертки хранится в регистре AX. Добавьте код для вывода результата по своему усмотрению.

## Заметки:
• Гарвардская архитектура: Команды и данные хранятся в разных адресных пространствах. В этом примере, array1_ptr и array2_ptr хранят адреса начала массивов в памяти данных, доступ к которым осуществляется через ds:bx и ds:cx.<br>
• Двухадресная команда add: В программе используются add bx, 2 и add cx, 2 для перехода к следующему элементу массива.<br>
• Числа без знака: Программа использует числа без знака, поэтому нет необходимости в команде mul (умножение без знака).