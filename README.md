
# Задание №1. Поиск максимума в массиве (Архитектура Гарвардская, двухадресная, без знака)


## Описание задачи: 
Написать программу на ассемблере, которая находит максимальный элемент в массиве целых чисел без знака, используя архитектуру Гарвардская и двухадресные команды.

## Входные данные
Массив из 6-15 элементов, хранящийся в памяти данных.

## Выходные данные

Максимальный элемент массива, хранящийся в регистре.

## Регистры
• AX: Используется для хранения текущего элемента массива и результата сравнения.
• BX: Указатель на начало массива (хранится в памяти данных).
• CX: Счетчик элементов массива.
• DX: Хранит максимальный элемент массива.

## Код:
```
.model small
.stack 100h

.data
    array dw 10, 5, 2, 8, 12, 7  ; Массив данных (без знака)
    array_size dw 6            ; Размер массива
    array_ptr dw offset array  ; Указатель на начало массива

.code
main proc
    mov ax, @data         ; Загрузка сегмента данных
    mov ds, ax             ; Установка сегмента данных

    mov cx, array_size    ; Загрузка размера массива
    mov bx, [array_ptr]     ; Загрузка указателя на массив
    mov dx, [bx]          ; Инициализация максимального элемента первым элементом

    loop_start:
        mov ax, [bx]      ; Загрузка текущего элемента массива
        cmp ax, dx          ; Сравнение с текущим максимальным элементом
        ja max_found        ; Если текущий элемент больше - обновляем максимальный
        add bx, 2            ; Переход к следующему элементу
        dec cx              ; Декремент счетчика
        jnz loop_start    ; Цикл по массиву

    max_found:
        mov ax, dx          ; Перемещение максимального элемента в AX
        
    ; Вывод результата (добавьте код для вывода результата в соответствии с вашими предпочтениями)
    
    mov ah, 4ch            ; Код прерывания для завершения программы
    int 21h               ; Вызов прерывания

main endp
end main

```
## Объяснение
1.  Инициализация: Программа загружает сегмент данных, инициализирует CX с размером массива, BX с адресом начала массива (из array_ptr) и DX первым элементом массива.
2. Цикл: В цикле loop_start текущий элемент загружается в AX и сравнивается с DX. Если текущий элемент больше, то DX обновляется.
3. Переход к следующему элементу: BX увеличивается на 2 для перехода к следующему элементу массива (размер слова 2 байта).
4. Счетчик: Счетчик CX уменьшается на 1.
5. Проверка счетчика: Если CX не равен нулю, цикл продолжается.
6. Вывод результата: Максимальный элемент находится в регистре AX. Добавьте код для вывода результата по своему усмотрению.

Заметки:<br>
• Гарвардская архитектура: Команды и данные хранятся в разных адресных пространствах. В этом примере, array_ptr хранит адрес начала массива в памяти данных, доступ к которому осуществляется через ds:bx.<br>
• Двухадресная команда add: В программе используется add bx, 2 для перехода к следующему элементу массива.<br>
• Сравнение без знака: Вместо jg используется ja (jump above), чтобы сравнить числа без учета знака.